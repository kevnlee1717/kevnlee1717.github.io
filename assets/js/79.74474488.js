(window.webpackJsonp=window.webpackJsonp||[]).push([[79],{238:function(s,t,a){"use strict";a.r(t);var v=a(28),e=Object(v.a)({},(function(){var s=this,t=s.$createElement,a=s._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h1",{attrs:{id:"寄存器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#寄存器"}},[s._v("#")]),s._v(" 寄存器")]),s._v(" "),a("h2",{attrs:{id:"寻址方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#寻址方式"}},[s._v("#")]),s._v(" 寻址方式")]),s._v(" "),a("ul",[a("li",[s._v("[x]直接寻址")]),s._v(" "),a("li",[s._v("[bx] 设置bx位0 然后 add bx,1/2 根据字节或者字递增寻址")]),s._v(" "),a("li",[s._v("[bx+x] 两个要操作的地址相隔x位，用这样的寻址，只用bx一个指针就可以操作两个地址")]),s._v(" "),a("li",[s._v("[bx+si/di] 设置两个明显的源和目标指针，用法跟上面差不多")])]),s._v(" "),a("h2",{attrs:{id:"通用寄存器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#通用寄存器"}},[s._v("#")]),s._v(" 通用寄存器")]),s._v(" "),a("blockquote",[a("p",[s._v("AX BX CX DX 用来进行计算，存储结果等")])]),s._v(" "),a("ul",[a("li",[s._v("bx 可以用来寻址的时候做 "),a("strong",[s._v("偏移基址")]),s._v("，配合loop 对一个连续的地址进行寻址")])]),s._v(" "),a("div",{staticClass:"language-ini line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-ini"}},[a("code",[a("span",{pre:!0,attrs:{class:"token selector"}},[s._v("[bx]")]),s._v("\nadd bx, 1/2 （1和2 表示了 字节和字的 递增）\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br")])]),a("ul",[a("li",[s._v("cx 用来设置 "),a("strong",[s._v("loop")]),s._v(" 的次数")])]),s._v(" "),a("h2",{attrs:{id:"地址寄存器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#地址寄存器"}},[s._v("#")]),s._v(" 地址寄存器")]),s._v(" "),a("blockquote",[a("p",[s._v("都是用来寻址的，不同的寄存器加上偏移来对代码，数据，栈等来进行寻址，对内存进行读写操作。")])]),s._v(" "),a("ul",[a("li",[a("p",[s._v("数据 ds + 【】")])]),s._v(" "),a("li",[a("p",[s._v("栈 ss + sp")]),s._v(" "),a("blockquote",[a("p",[s._v("sp 设置了栈的大小，比如设置为f (16 byte) 那么就可以push8次，因为每次push都是以字型为单位，push两个byte,虽然理论上是8次，但是实际上并不进行检查，多出来的push 和 pop 会发生越界。")])]),s._v(" "),a("blockquote",[a("p",[s._v("push 的时候 sp-2 然后push")])]),s._v(" "),a("blockquote",[a("p",[s._v("pop 的时候sp+2 然后pop")])]),s._v(" "),a("ul",[a("li",[s._v("栈的作用\n"),a("ul",[a("li",[s._v("当函数跳转开始的时候保存ip， 返回的时候取回ip")]),s._v(" "),a("li",[s._v("保存临时数据，把要保存的寄存器或者内存地址先push")])])])])]),s._v(" "),a("li",[a("p",[s._v("代码 cs + ip")]),s._v(" "),a("blockquote",[a("p",[s._v("cs就是代码段开始的位置，但是不一定是程序开始执行的位置，伪指令start才是程序开始执行的地方，那么cs到start的这段内存空间，可以存放自己定义的数据，定义的数据里，可以拿一部分做为自己的栈。 栈ss设置为cs，sp设置为start-cs的字节数。")])]),s._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[s._v("  ``` ini\n\n  code segment\n\n\n          dw 11,22,33,44,55,66,77,88  ;自定义的数据\n          dw 0,0,0,0,0,0,0,0          ;可以做为栈\n\n  start:  mov ax, cs  ;程序执行的地方\n          mov ss, ax  ;设置栈段为 代码段开始地方\n          mov sp, 16  ;设置栈大小为16个字\n\n\n  code ends\n\n  ```\n")])])])])]),s._v(" "),a("div",{staticClass:"custom-block danger"},[a("p",{staticClass:"custom-block-title"},[s._v("WARNING")]),s._v(" "),a("p",[s._v("寄存器都是以字型数(16bit 2字节)来操作的,高地址存高位，低地址存低位，比如 1122h 存储后就是 22 11 在内存中。")])])])}),[],!1,null,null,null);t.default=e.exports}}]);